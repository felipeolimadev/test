

# If a proper interval T1 is intervalOverlaps another proper interval T2,
# then the beginning of T1 is before the beginning of T2,
# the end of T1 is after the beginning of T2, and the end of T1 is before the end of T2.
time:intervalOverlaps[?T1, ?T2]
    :-
    rdfs:subClassOf[?AACTIVITY, time:Interval],
        rdf:type[?T1, ?AACTIVITY],
        time:hasBeginning[?T1, ?T1begin],
        time:hasEnd[?T1, ?T1end],
    rdfs:subClassOf[?BACTIVITY, time:Interval],
        rdf:type[?T2, ?BACTIVITY],
        time:hasBeginning[?T2, ?T2begin],
        time:hasEnd[?T2, ?T2end],
    FILTER(?T1 != ?T2),
    time:inXSDDateTimeStamp[?T1begin, ?T1beginTime],
    time:inXSDDateTimeStamp[?T1end, ?T1endTime],
    time:inXSDDateTimeStamp[?T2begin, ?T2beginTime],
    time:inXSDDateTimeStamp[?T2end, ?T2endTime],
    FILTER(?T1beginTime < ?T2beginTime && ?T1endTime > ?T2beginTime && ?T1endTime < ?T2endTime).


# If a proper interval T1 is intervalIn another proper interval T2,
# then the beginning of T1 is after the beginning of T2 or is coincident with the beginning of T2,
# and the end of T1 is before the end of T2 or is coincident with the end of T2,
# except that end of T1 may not be coincident with the end of T2
# if the beginning of T1 is coincident with the beginning of T2.
# T2B < T1B < T1E < T2E
time:intervalIn[?T1, ?T2]
    :-
    rdfs:subClassOf[?AACTIVITY, time:Interval],
        rdf:type[?T1, ?AACTIVITY],
        time:hasBeginning[?T1, ?T1begin],
        time:hasEnd[?T1, ?T1end],
    rdfs:subClassOf[?BACTIVITY, time:Interval],
        rdf:type[?T2, ?BACTIVITY],
        time:hasBeginning[?T2, ?T2begin],
        time:hasEnd[?T2, ?T2end],
    FILTER(?T1 != ?T2),
    time:inXSDDateTimeStamp[?T1begin, ?T1beginTime],
    time:inXSDDateTimeStamp[?T1end, ?T1endTime],
    time:inXSDDateTimeStamp[?T2begin, ?T2beginTime],
    time:inXSDDateTimeStamp[?T2end, ?T2endTime],
    FILTER( (?T1beginTime > ?T2beginTime && ?T1endTime < ?T2endTime)
        || (?T1beginTime = ?T2beginTime && ?T1endTime < ?T2endTime)
        || (?T1beginTime > ?T2beginTime && ?T1endTime = ?T2endTime)
    ).

# If a proper interval T1 is intervalEquals another proper interval T2,
# then the beginning of T1 is coincident with the beginning of T2,
# and the end of T1 is coincident with the end of T2.
time:intervalEquals[?T1, ?T2]
    :-
    rdfs:subClassOf[?AACTIVITY, time:Interval],
        rdf:type[?T1, ?AACTIVITY],
        time:hasBeginning[?T1, ?T1begin],
        time:hasEnd[?T1, ?T1end],
    rdfs:subClassOf[?BACTIVITY, time:Interval],
        rdf:type[?T2, ?BACTIVITY],
        time:hasBeginning[?T2, ?T2begin],
        time:hasEnd[?T2, ?T2end],
    FILTER(?T1 != ?T2),
    time:inXSDDateTimeStamp[?T1begin, ?T1beginTime],
    time:inXSDDateTimeStamp[?T1end, ?T1endTime],
    time:inXSDDateTimeStamp[?T2begin, ?T2beginTime],
    time:inXSDDateTimeStamp[?T2end, ?T2endTime],
    FILTER(?T1beginTime = ?T2beginTime && ?T1endTime = ?T2endTime) .



# An instant that falls inside the interval.
# It is not intended to include beginnings and ends of intervals.
time:inside[?A, ?B]
    :-
    rdfs:subClassOf[?AACTIVITY, time:Interval],
        rdf:type[?A, ?AACTIVITY],
        time:hasBeginning[?A, ?Abegin],
        time:hasEnd[?A, ?Aend],
    rdfs:subClassOf[?BACTION, time:Instant],
        rdf:type[?B, ?BACTION],
    FILTER (?BACTION != user:Action),
    time:inXSDDateTimeStamp[?Abegin, ?AbeginTime],
    time:inXSDDateTimeStamp[?Aend, ?AendTime],
    time:inXSDDateTimeStamp[?B, ?BTime],
    FILTER(?AbeginTime < ?BTime && ?AendTime > ?BTime).

